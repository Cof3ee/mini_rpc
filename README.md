# Mini RPC для STM32 (на базе FreeRTOS)

## Общая идея  
Проект служит тестовым заданием: аппаратно-независимая логика (канал/транспорт/реестр/клиент/сервер) + интеграция с HAL и FreeRTOS.   
Проект написан через модульную систему, на языке `C++` с использованием `CMake` для аппаратно-независимых файлов.  
Для генерации технической части проекта использовался `STM32CubeMX`, для разработки технической части использовалалась  среда разработки `IAR`.  
Передача сообщений осуществляется по UART, данные кодируются в кадры (frame) через слой `channel`, затем сериализуются (`transport`) и обрабатываются на стороне сервера или клиента.  

### Проект написан для микроконтроллера `STM32F051C8T6TR`.  

---

## Содержание README

- [Что реализовано](#что-реализовано)  
- [Архитектура и принцип работы](#архитектура-и-принцип-работы)   
- [Ограничения и предложения по улучшению](#ограничения-и-предложения-по-улучшению)  
- [Запуск проекта](#запуск-проекта)

## Что реализовано  
- Канальный уровень: фрейминг с заголовком, длиной и CRC8, старт/стоп-байты (0xFA…0xFE).  
- Транспортный уровень: простая сериализация `transport_message` (type, id, name, data).  
- Реестр функций (`registry`) для вызова локальных функций по имени.  
- Клиентская обёртка (`Client_RPC`) — отправка запросов и хранение ответов.  
- Серверная часть (`Server_RPC`) — приём запросов, вызов функции и формирование ответа.  
- HAL/UART интеграция: неперебивающая отправка, приём через ISR и передача байтов в декодер (через очередь/задачу FreeRTOS).  
- FreeRTOS используется для задач передачи/приёма и для синхронизации.  

---

## Архитектура и принцип работы

1. **Клиент** формирует `transport_message` (type=REQ/STREAM), сериализует (`transport_encode`), оборачивает в кадр (`channel_encode`) и вызывает `send_packet()` (аппаратно-зависимая функция HAL).
2. **Физический уровень (UART ISR)** читает байты, кладёт их в очередь или буфер; задача приёма под FreeRTOS читает байты по очереди и feed'ит `ChannelDecoder::feed()`.
3. Когда кадр полностью собран и CRC верен, извлекается payload и вызывается `transport_decode()` для получения `transport_message`.
4. Если это `REQ`, `Server_RPC` ищет функцию в `registry` и вызывает её с аргументами; возвращаемое значение формируется в `RESP` (или `ERR` при ошибке).
5. Если это `RESP/ERR`, `Client_RPC::on_response()` сохраняет ответ по `id` в локальное хранилище; приложение может извлечь ответ через `pop_response(id, out)`.  

## Ограничения и предложения по улучшению

### 1. Контрольная сумма
**Недостаток:** Слабая контрольная сумма (CRC8) — недостаточно стойка к ошибкам на шумных линиях.  
**Предложение:** Поменять CRC8 на CRC16 (или CRC32) — одна CRC над всем фреймом, надёжнее обнаруживает ошибки.

### 2. Ресурсы
**Недостаток:** Риск исчерпания ресурсов — нет ограничений на размер payload, число одновременных вызовов и т.п.  
**Предложение:** Ввести MAX_PAYLOAD, лимит одновременных вызовов, пул буферов (избегать malloc в hot-path).

### 3. Текстовые имена функций
**Недостаток:** Текстовые имена функций в каждом пакете — много лишнего трафика и затрат на парсинг.  
**Предложение:** Заменить текстовые имена на numeric IDs (16/32-bit) и держать таблицу ID↔name отдельно.

### 4. Стримы и долгоживущие операции
**Недостаток:** Тип сообщения стрим указан, но нет описания semantics: как идентифицировать границы stream сообщений, как управлять потоками и их закрытием.  
**Предложение:** Описать семантику стримов: open/data/close, добавить sequence номера, идентификаторы потоков и правила завершения.

### 5. Ошибки
**Недостаток:** Есть тип ошибка, но не определены стандартизованные коды ошибок, структура полезной нагрузки ошибки, и поведение сторон при ошибке.  
**Предложение:** Включить таблицу кодов ошибок, чётко задать формат payload ошибки и поведение обеих сторон при возникновении ошибки.

### 6. Безопасность
**Недостаток:** Нет механизмов безопасности — отсутствие аутентификации или защиты от replay делает протокол уязвимым.  
**Предложение:** Добавить опциональную безопасность — HMAC / nonce / timestamp для аутентификации и защиты от replay; предусмотреть proto_ver для совместимости.

### 7. Таймаут ответа
**Недостаток:** Нет чёткого таймаута ответа — не описано, сколько ждать ответа и что делать, если он не пришёл.  
**Предложение:** Задокументировать таймауты: сколько ждать ответа, сколько попыток повторить запрос.

### 8. Версия протокола
**Недостаток:** Нет версионирования протокола — если формат поменяется, старое устройство может не понять новое.  
**Предложение:** Добавить поле версии протокола (proto_ver) в заголовок.

## Запуск проекта 
**Для запуска проекта:**  
-клонировать репазиторий  
-в папке проекта перейти по пути: mini_rpc_EWARM\mini_rpc\EWARM
-запустить файл `Project.eww`



